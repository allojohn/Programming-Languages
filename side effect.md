> Classes should be immutable unless there's a very good reason to make them mutable... If a class cannot be made immutable,you should still limit its mutability as much as possible.
——Joshua Bloch （Java architect）

### 值与引用
值类型与引用类型的区别，并不在于它们存放的位置，而是他们存储的内容。值类型存储的内容是值，而引用类型实际上是一个指称。而很多问题之所以会出现，实际上在于多个引用对象可能对应于同一个值类型。如果其中一个引用类型的值发生了变化，那么实际上对应的值类型就会发生变化。那其他的引用类型就会在瞬间改变。那怎么解决这样的一个问题呢？
在Java中，解决这个问题的方法非常简单，实际上就是当引用类型的值发生改变时，我们只需要新建一个新的值类型，让它指向这个地方，而原有的值类型并不改变。这样，就避免了Aliasing问题。
### 模块
没有副作用的好处之一，是函数可以**任性地**使用aliasing以及copy操作，完全不用担心对方被修改。而拥有副作用的写法就没这么好运了。
```
int a = 888;
int 
```


### 并发
缺少side-effet非常适合并发。例如，对于函数 `f(x) * g(x)` ，因为无副作用，所以f(x) 与 g(x) 可以同时进行计算。类似地，像map(),filter()这样的语言特性，非常适合大规模分部式处理数据。因为数据之间互不影响，数组中元素的执行顺序可以不固定。我们只需要一个合理的分发数据的算法即可。

### 数据结构
完全没有副作用的函数式被称为“纯”函数式，Haskell是其中典型。然而完全的OOP与完全的FP都不合适。语言要做的，是对世界进行建模。吉布森曾说“未来已经到来，只是分布不均”。**这句话同样可以用于解释OOP与FP的矛盾**。这个世界并非那么均匀，某些地方合适使用OOP，某些时候则是FP，另外一些，则是FP与OOP的综合。
然而没有副作用并非全然都是好事。对于某些数据结构来说，使用副作用至关重要。像数组中数据的更新，一定需要使用副作用。许多的算法都需要使用数组类型，如mergesort,quicksort，如果没有副作用，效率将完全不同。否则每次更新都需要新建一个数组。我自己读过Purely functional data structures这本书的一部分，作者在其中介绍了用纯函数式编写算法的思想。在前面的章节中，作者用纯函数式写Red-Black Trees、BST，算法都非常简洁。但是看了作者说了什么很重要，**他没说什么也很重要。**因为BST以及红黑树都是二分操作，完全适合列表的car ，cdr操作。而对于之前说的需要适用数组的类型，则无能为力了。



