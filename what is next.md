语言特性的研究有利于思考语言，但是它远远不是终点。未来是什么？未来是研究编译器（解释器）。
### 逆向工程
利用已有的建筑学知识去造房子，是正向的工程学。而从一个已有的构造去反推它的运行原理，便是逆向工程。以心理学为例，人人都对人性有一个直观印象，这些有助于我们与人的交往。但是这些只是简单的朴素归纳，是folk psychology，不能解决更加复杂的人类现象。**简单的模型和有效的解释是一对矛盾**，我们需要个更加细致的解释。
同样，当我们尝试去思考编程这件事时，我们平时接触的编程原则，也只是简化的论述：数组、map（）的用法和功能是什么。这些论述可以用来处理比较简单的问题。但是如果我们出错了，我们却需要开始解决更加底层的问题。编译器的报错信息，往往是底层的信息。在这种时候，如果想要debug，程序员在做的，恰恰是**将底层的信息翻译成高层的信息**。

摘录GEB的一段内容，我觉得讲得非常好。
> 程序正常运行时，你怎么描述它或想象它的活动都没有太大关系。**只有在出了毛病时，能够在不同的层次上思考才变得重要起来**。例如，如果程序在某时要执行除法指令，而除数是零，程序将暂停运行，并把问题通知使而除数是零，程序将暂停运行，并把问题通知使用者，报告程序中出错的位置。但是，给出说明的层次往往低于程序员书写该程序的层次。下面是对一个嘎然而止的程序的三个平行的描述：
* 机器语言层：程序执行停止于1110010101110111位置；
* 汇编语言层：程序执行停止于遇到DIV（除）指令时；
* 编译语言层：程序执行停止于为代数表达式‘(A+B)/Z’赋值的过程中。

这就是Joel Spoky讲的「抽象必漏定律」(the law of leaky abstraction)。
对于系统程序员（指那些编写编译程序、解释程序、汇编程序和其它一些供大家使用的程序的人）来说，最大的问题之一就是搞明白编译器报错的内容到底是什么，以便给那些程序出错的用户**提供高层而非低层的问题描述信息**。
诶，遗憾自己现在还没有这样的技能。