Ruby中的一些特点，如dynamic dispatch，实际上是在试图解决什么矛盾？看起来，它解决的矛盾是，当子类出现与父类同名的方法时，优先考虑哪一个的问题，考虑的顺序是什么样的。能不能用一套清晰的规则去描述它。我们看到，这里的规则就是根据调用的对象来指定self，而方法是与self绑定的，因此通过指定self之后，我们就可以很直接的找到对应的类。那么，self如果找不到，我们就可以找self.class，这也是在设计上非常简单的方法，很直接，就是利用self中的种种方法。

那么double dispatch又是什么意思？这个的意思是，之前我们试图将这个对象中的东西用另一个对象中的同名方法来处理，但是却发现它仍然处理不好，它只能做部分工作，我们仍然需要调用另一半的同名方法，因此，我们便需要调用另一个对象中的方法，来处理这件事情。这便是整个过程的来龙去脉。

对于OOP来说，它与FP的最大区别是什么？

我想，最大的区别在于，在fp中，添加方法是非常简单的，你只要新建一个过程就可以了，这样你就可以传递其他数据进来进行处理，但是在新建数据方面，这就有点牵一发而动全身了：其他函数的case分析都要再加上一些内容。这便是在EOPL写解释器时面临的窘境：所有的相关函数，因为新的数据出现，都要发生改动。那么，有没有什么方法，我可以做到让它变得简单一点？能力有限，FP的”设计模式“暂时还不了解，我只能写到这里。。。 

