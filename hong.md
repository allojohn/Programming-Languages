### 自定义

Lisp中的宏与C的宏完全不同。C中的宏，我理解为是简单的字符替换，它在编译之前完成，也正是因为这个特点，让C的一些宏产生了问题：

```
#define ADD(x,y) x+y
ADD(1,2/3)*4
```

我们希望的结果是`(1 + 2/3) * 4` ，但是实际结果是 `1 + 2/3 * 4` 。因此，C中的宏需要添加大量括号来保证程序不出错。而在像Racket的语言中，没有这样的问题。如果我之前将head定义为car：`(define- syntax head car) `是，并不会简单的代换为 ` (cart foo)`

### 关键

使用S-表达式的语言，之所以能够在宏方面展现威力，关键在于它本身的特点：在写程序时所用的操作，实际上直接对应解释器中的内容。仔细看解释器的具体实现，就可以发现，其中就是一系列的case expression，对不同的操作符采取不同求值方式。这一所见即所得的特点，很容易运用宏：在解释器中添加其他的操作，而这些操作，和写程序的操作，完全相同。如我们在写程序时写了一个`(+ 3 9)`,那么，解释器中的case expressio中，直接对应的也是`(case '+ ······)`，那么就没什么可以组织我们做一个模仿：在解释其中添加一个case expression : `(case  'myplus+ ······）`这样，我在写程序的时候，也可以直接使用myplus来表达我想要的操作。

### 问题

宏最大的问题，在于它**不能方便所有人**。我们可以用接口隐喻来理解。程序语言要做到写起来方便，还要方便看代码的人，自己当时定义的宏虽然用起来很舒服，可看代码的人，却要额外花功夫，去考虑这些宏到底是什么意思。因此，它实际是一个极**既不方便的接口**。也许，只有在少数情况下，宏才是更好的选择。

